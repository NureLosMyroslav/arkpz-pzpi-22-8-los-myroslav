МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ

Кафедра «Програмної інженерії»



ЗВІТ
З Лабораторної роботи № 3
з дисципліни
«Аналіз та рефакторинг коду»


Виконав: 
ст. гр. ПЗПІ-22-8
Лось М.О.

Перевірив: 
ст. викладач кат. ПІ 
Сокорчук І.П.



Харків 2024


3 РОЗРОБКА БІЗНЕС-ЛОГІКИ ТА ФУНКЦІЙ АДМІНІСТРУВАННЯ СЕРВЕРНОЇ ЧАСТИНИ ПРОГРАМНОЇ СИСТЕМИ

3.1	Мета роботи
Розробити бізнес-логіку та функції адміністрування серверної частини програмної системи.
3.2	Хід роботи
У ході виконання роботи була реалізована серверна частина системи NoiseControl, що відповідає за прийом та обробку даних із шумових датчиків. Основним джерелом інформації є IoT-датчик, змодельований на ESP32, який передає значення рівня шуму через MQTT-брокер HiveMQ.
Підключення ESP32 до брокера відбувалося через PubSubClient, а обробка та збереження отриманих даних реалізовані на Node.js з використанням MS SQL Server. Для кожного нового значення сервер створює запис у таблиці Measurements, додаючи інформацію про ідентифікатор сенсора, рівень шуму та час вимірювання.
Одним із важливих завдань було забезпечення захисту доступу до даних. Було реалізовано JWT-автентифікацію, що дозволяє ідентифікувати користувачів та обмежувати доступ до адміністративних функцій. Лише авторизовані адміністратори можуть переглядати історичні дані, видаляти записи та керувати зонами моніторингу шуму.
Для зручності взаємодії з API у проект інтегровано Swagger UI, що дозволяє легко тестувати серверні маршрути, переглядати отримані дані та виконувати адміністративні операції.
Усі компоненти були протестовані, зокрема механізми отримання даних, збереження їх у базі, автентифікація користувачів та обробка запитів. Отримані результати підтвердили коректну роботу системи, а також її здатність у реальному часі приймати дані з датчиків, аналізувати їх та відображати історію вимірювань. Таким чином, розроблена система NoiseControl є ефективним рішенням для моніторингу рівня шуму та контролю екологічного стану у міських зонах.

3.2.1	Опис інженерних рішень
Для реалізації системи NoiseControl була розроблена серверна частина, що забезпечує прийом, обробку та збереження даних з IoT-датчиків. Серверна логіка побудована на основі Node.js з використанням фреймворку Express.js для ефективного управління HTTP-запитами. Для взаємодії з базою даних використовується MS SQL Server, а передавання даних від сенсорів здійснюється через MQTT-брокер HiveMQ.
Дані про рівень шуму збираються за допомогою мікроконтролера ESP32, підключеного до потенціометра, що моделює датчик шуму. ESP32 зчитує значення рівня шуму та кожні 5 секунд відправляє дані у форматі JSON через MQTT. Сервер приймає повідомлення, перевіряє їх коректність, а потім зберігає у таблиці Measurements бази даних.
Для безпеки даних та обмеження доступу впроваджено JWT-автентифікацію. Користувачі, що входять у систему, отримують унікальний токен, який дозволяє їм отримувати доступ до API. Адміністратори мають розширені права для перегляду історичних даних, видалення записів та управління датчиками.
Система також передбачає механізм автоматичних сповіщень: якщо рівень шуму перевищує встановлений поріг, сервер генерує відповідне повідомлення, яке може бути використане для аналізу та подальшого реагування.
Для спрощення тестування API та взаємодії з сервером була реалізована Swagger-документація, що містить усі доступні маршрути, їхні параметри та приклади відповідей.
Завдяки таким технічним рішенням система NoiseControl дозволяє ефективно моніторити шумове забруднення, зберігати історію вимірювань та керувати процесом збору даних у міських умовах.

3.2.2	Фрагменти програмного коду
Бізнес логіки (математичних методів обробки даних) серверної частини;

//Додавання нового вимірювання шуму в буфер останніх значень
noiseHistory.push(measured_value);
if (noiseHistory.length > 3) {
    noiseHistory.shift(); // Видалення найстарішого значення для збереження лише останніх 3 вимірювань
}

//Розрахунок середнього рівня шуму на основі останніх 3 вимірювань
if (noiseHistory.length === 3) {
    const avgNoise = noiseHistory.reduce((sum, val) => sum + val, 0) / 3; // Обчислення середнього арифметичного
    console.log(`Обчислений середній рівень шуму (на основі 3 останніх вимірювань): ${avgNoise.toFixed(2)} дБ`);

    // Аналіз перевищення допустимого рівня шуму
    if (avgNoise > 60) {
        console.warn(`Попередження! Середній рівень шуму перевищено: ${avgNoise.toFixed(2)} дБ`);
    }
}
// Функція для додавання користувача
async function addUser(username, password, email, role) {
    const hashedPassword = await bcrypt.hash(password, 10);
    const query = 'INSERT INTO Users (username, password, email, role) VALUES (@username, @password, @email, @role) RETURNING id, username, email, role';
    const values = { username, password: hashedPassword, email, role };

    try {
        const result = await sql.query(query, values);
        return result.recordset[0];
    } catch (err) {
        throw new Error('Помилка при додаванні користувача: ' + err.message);
    }
}

// Функція для видалення користувача
async function deleteUser(userId) {
    const query = 'DELETE FROM Users WHERE id = @userId RETURNING id, username, email, role';
    const values = { userId };

    try {
        const result = await sql.query(query, values);
        if (result.recordset.length === 0) {
            throw new Error('Користувача з таким ID не знайдено');
        }
        return result.recordset[0];
    } catch (err) {
        throw new Error('Помилка при видаленні користувача: ' + err.message);
    }
}

// Функція для додавання даних з сенсора
async function addSensorData(sensor_id, measured_value) {
    const query = 'INSERT INTO Measurements (sensor_id, measured_value, measurement_time) VALUES (@sensor_id, @measured_value, GETDATE()) RETURNING id, sensor_id, measured_value, measurement_time';
    const values = { sensor_id, measured_value };

    try {
        const result = await sql.query(query, values);
        return result.recordset[0];
    } catch (err) {
        throw new Error('Помилка при додаванні даних сенсора: ' + err.message);
    }
}

// Функція для зміни даних сенсора
async function updateSensorData(sensor_id, new_value) {
    const query = 'UPDATE Measurements SET measured_value = @new_value WHERE sensor_id = @sensor_id RETURNING id, sensor_id, measured_value, measurement_time';
    const values = { sensor_id, new_value };

    try {
        const result = await sql.query(query, values);
        return result.recordset[0];
    } catch (err) {
        throw new Error('Помилка при оновленні даних сенсора: ' + err.message);
    }
}

// Функція для отримання всіх користувачів
async function getAllUsers() {
    const query = 'SELECT id, username, email, role FROM Users';
    
    try {
        const result = await sql.query(query);
        return result.recordset;
    } catch (err) {
        throw new Error('Помилка при отриманні списку користувачів: ' + err.message);
    }
}

// Функція для отримання всіх сенсорів
async function getAllSensors() {
    const query = 'SELECT id, zone_id, sensor_name, install_date FROM Sensors';
    
    try {
        const result = await sql.query(query);
        return result.recordset;
    } catch (err) {
        throw new Error('Помилка при отриманні списку сенсорів: ' + err.message);
    }
}

// Функція для отримання всіх зон
async function getAllZones() {
    const query = 'SELECT id, zone_name, description FROM NoiseZones';
    
    try {
        const result = await sql.query(query);
        return result.recordset;
    } catch (err) {
        throw new Error('Помилка при отриманні списку зон: ' + err.message);
    }
}
3.2.3 Висновки:
 У ході виконання лабораторної роботи було розроблено серверну частину програмної системи для моніторингу рівня шуму в міських зонах. Система успішно реалізує базову бізнес-логіку, забезпечуючи збір, збереження та аналіз даних із шумових датчиків. Завдяки використанню сучасних технологій, таких як Node.js, Express.js та Microsoft SQL Server, вдалося створити продуктивну, масштабовану та надійну архітектуру.
Основна увага була приділена обробці та аналізу шумових даних. Реалізовано механізми обчислення середнього рівня шуму на основі останніх вимірювань, що дає змогу оцінювати перевищення допустимих норм у реальному часі. Крім того, система інтегрує MQTT-протокол для отримання даних від IoT-датчиків, що дозволяє оперативно реагувати на зміни в акустичному середовищі.
Отже, створена система є ефективним рішенням для моніторингу шумового забруднення в міських умовах, що може бути використано муніципальними службами та дослідницькими організаціями для контролю та покращення якості життя населення.
3.2.4	Розробка UML діаграми діяльності для серверної частини
 
Рисунок 3.1 - UML діаграма діяльності для серверної частини






3.2.4	Розробка UML діаграми взаємодії для серверної частини
 
Рисунок 3.2 - UML діаграма взаємодії для серверної частини

Посилання на відео: https://youtu.be/dF7wV2bh_fE
